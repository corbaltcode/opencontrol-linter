#!/usr/bin/env ruby
# frozen_string_literal: true

require 'yaml'
require 'json'
require 'pp'
require 'date'
require 'colorize'
require 'rubyXL'
require 'rubyXL/convenience_methods/cell'
require 'rubyXL/convenience_methods/worksheet'
require 'rationalist'

CFACTS_WORKBOOK_INDEX = 0
CFACTS_CONTROL_KEY_COLUMN_INDEX = 2
CFACTS_NARRATIVE_COLUMN_INDEX = 5

DEFAULT_OPENCONTROLS_FILENAME = './opencontrols/opencontrol.yaml'
DEFAULT_CFACTS_XLSX_FILENAME = './assets/opencontrol.cfacts.xlsx'
DEFAULT_CFACTS_XLSX_OUTPUT_FILENAME = './opencontrols/opencontrol.cfacts.xlsx'

USAGE_TEXT = <<USAGE_TEXT
    usage: opencontrol2cfacts
    Usually used with a control masonry process that outputs merged yaml results.

    optional arguments:
      -h, --help            show this help message and exit
      -i, --cfacts_in_filename --input
                            Specify the xlsx spreadsheet file input from cfacts
                            (this should contain your various id's).
                            defaults to #{DEFAULT_CFACTS_XLSX_FILENAME}
      -o, --cfacts_out_filename --output
                            Specify the xlsx spreadsheet file output for cfacts
                            (this should contain your various id's).
                            defaults to #{DEFAULT_CFACTS_XLSX_OUTPUT_FILENAME}
      -v, --version         Show the version of this utility.

    Usage examples:

        # convert using default directories #{DEFAULT_OPENCONTROLS_FILENAME}
        # #{DEFAULT_CFACTS_XLSX_FILENAME} to #{DEFAULT_CFACTS_XLSX_OUTPUT_FILENAME}
         opencontrol2cfacts

        # lint all components subdir components
         opencontrol2cfacts --input './cfacts.inputfile.xslx'
USAGE_TEXT

ALIASES = {
  input: %w[i cfacts_in_filename],
  output: %w[o cfacts_out_filename],
  controls: %w[c opencontrols_filename],
  help: 'h',
  version: 'v'
}.freeze

VERSION = '0.1'

def write_when_empty_merge_strategy(row, narrative)
  if row[CFACTS_NARRATIVE_COLUMN_INDEX].nil? ||
     row[CFACTS_NARRATIVE_COLUMN_INDEX].value.nil? ||
     row[CFACTS_NARRATIVE_COLUMN_INDEX].value.strip == ''
    row[CFACTS_NARRATIVE_COLUMN_INDEX].change_contents(narrative)
  end
end

def merge_response(row, narrative)
  write_when_empty_merge_strategy(row, narrative)
end

def read_opencontrols_yaml(opencontrols_filename)
  puts ' . Reading OpenControl components:'
  YAML.load_file(opencontrols_filename)
end

def build_narrative(key, control, control_responses)
  control['narrative'].each do |narrative|
    control_responses[key]['text'] += key + "\n"
    control_responses[key]['text'] += narrative['text']
    control_responses[key]['text'] += "\n"
  end
end

def narrative?(key, control_responses)
  control_responses[key].key?('text')
end

def build_control_response(key, control, control_responses)
  control_responses[key] = {} unless control_responses.key?(key)
  control_responses[key]['text'] = '' unless narrative?(key, control_responses)
  control_responses[key]['control_key'] = control['control_key']
  control_responses[key]['standard_key'] = control['standard_key']
  build_narrative(key, control, control_responses)
end

def key_for_control(control)
  "#{control['standard_key']} #{control['control_key']}"
end

def build_control_responses(opencontrols)
  control_responses = {}
  opencontrols['data']['components'].each do |component|
    puts "    . #{component['name']}"
    component['satisfies'].each do |control|
      key = key_for_control(control)
      build_control_response(key, control, control_responses)
    end
  end
  control_responses
end

def row_malformed?(row)
  row.nil? || row.size < CFACTS_CONTROL_KEY_COLUMN_INDEX
end

def control_key_matches?(control_key, control_response)
  control_key == control_response['control_key'].strip
end

def maybe_merge_into_row(row, row_number, control_response)
  if row_malformed?(row)
    puts "Skip malformed row (line no. #{row_number} [#{row}])" unless row.nil?
  else
    control_key = row[CFACTS_CONTROL_KEY_COLUMN_INDEX].value.strip
    # puts "Searching in row #{control_key}"
    if control_key_matches?(control_key, control_response)
      merge_response(row, control_response['text'])
    end
  end
end

def ensure_cells_present(worksheet, row_number)
  if worksheet[row_number][CFACTS_NARRATIVE_COLUMN_INDEX].nil?
    worksheet.insert_cell(row_number, CFACTS_NARRATIVE_COLUMN_INDEX, '')
  end
end

def locate_and_merge_control(worksheet, control_response)
  puts "    . #{control_response['control_key']}"
  # we have to locate the key in the sheet - skip the titles row
  1.upto(worksheet.sheet_data.size) do |row_number|
    row = worksheet[row_number]
    unless row.nil?
      ensure_cells_present(worksheet, row_number)
      maybe_merge_into_row(row, row_number, control_response)
    end
  end
end

def update_workbook(in_filename, control_responses, out_filename)
  puts ' . Building CFACTS file:'
  workbook = RubyXL::Parser.parse(in_filename)
  worksheet = workbook[CFACTS_WORKBOOK_INDEX]
  control_responses.each do |_key, control_response|
    locate_and_merge_control(worksheet, control_response)
  end
  workbook.write(out_filename)
end

def no_opencontrol_exit
  puts 'Expected an opencontrol.yaml, but could not find opencontrol.yaml ' +
       'in this directory.'.red
  exit(1)
end

def check_files_exist(opencontrols_filename)
  no_opencontrol_exit unless File.exist?(opencontrols_filename)
end

def self.parse_args(arguments)
  opts = Rationalist.parse(arguments, alias: ALIASES)

  exit(show_version)  if opts[:version]
  exit(show_help)     if opts[:help]

  opts[:controls] = DEFAULT_OPENCONTROLS_FILENAME unless opts.key?(:controls)
  opts[:input] = DEFAULT_CFACTS_XLSX_FILENAME unless opts.key?(:input)
  opts[:output] = DEFAULT_CFACTS_XLSX_OUTPUT_FILENAME unless opts.key?(:output)
  opts
end

def show_help
  puts USAGE_TEXT
  0 # exit with no error
end

def show_version
  puts 'opecontrol2cfacts: v' + VERSION
  puts 'CMS 2019 Adrian Kierman '
  0 # exit with no error
end

def main
  opts = parse_args(ARGV)
  opencontrols_filename = opts[:controls]
  in_filename =           opts[:input]
  out_filename =          opts[:output]
  puts 'OpenControl conversion to CSV CFACTS format starting'.green

  check_files_exist(opencontrols_filename)
  opencontrols = read_opencontrols_yaml(opencontrols_filename)
  control_responses = build_control_responses(opencontrols)
  update_workbook(in_filename, control_responses, out_filename)

  puts 'Completed (OpenControl 2 CFACTS)'.green
end

# only run main if called directly - don't call it if running as a library
main if $PROGRAM_NAME == __FILE__
